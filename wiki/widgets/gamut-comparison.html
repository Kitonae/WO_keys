<div class="interactive-widget" id="gamut-comparison-widget"
    style="display: flex; flex-direction: column; align-items: center;">
    <canvas id="gamut-canvas" width="600" height="600"></canvas>
    <div class="widget-controls">
        <label><input type="checkbox" id="show-srgb" checked> sRGB / Rec. 709</label>
        <label><input type="checkbox" id="show-rec2020"> Rec. 2020</label>
        <label><input type="checkbox" id="show-rec601"> Rec. 601</label>
    </div>
    <div class="widget-explainer">
        The <strong>Rec. 2020</strong> triangle covers a significantly larger area of visible colors than the standard
        <strong>sRGB</strong> space.
    </div>
</div>
<script>
    (function () {
        const canvas = document.getElementById('gamut-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Spectral locus approximation (simplified 1931 observer)
        const locus = [
            [0.175596, 0.005296], [0.172787, 0.0048], [0.1708, 0.0054], [0.1703, 0.0058], [0.1664, 0.0086], [0.1606, 0.0145], [0.1566, 0.0177],
            [0.151, 0.0227], [0.1415, 0.0379], [0.1355, 0.0525], [0.1266, 0.0813], [0.1193, 0.1187], [0.1111, 0.1857], [0.1009, 0.2974], [0.0931, 0.4079],
            [0.0818, 0.5284], [0.074, 0.6481], [0.0766, 0.7251], [0.0863, 0.7761], [0.1205, 0.8175], [0.163, 0.8177], [0.2078, 0.7892], [0.2647, 0.7297],
            [0.3204, 0.6635], [0.3703, 0.5968], [0.4193, 0.5317], [0.465, 0.4687], [0.5097, 0.4101], [0.5518, 0.3585], [0.591, 0.3093], [0.627, 0.2625],
            [0.6586, 0.2206], [0.6865, 0.1834], [0.7088, 0.153], [0.7231, 0.1332], [0.7347, 0.1172], [0.7347, 0.005296]
        ];
        // Close the loop implies the straight line of purples, but for point-in-poly we want strict closure
        // The array above describes the curved part. The bottom is the line of purples.

        const primaries = {
            srgb: { r: [0.64, 0.33], g: [0.30, 0.60], b: [0.15, 0.06], color: 'rgba(255, 215, 0, 0.8)', label: 'sRGB/709' },
            rec2020: { r: [0.708, 0.292], g: [0.170, 0.797], b: [0.131, 0.046], color: 'rgba(147, 51, 234, 0.8)', label: 'Rec.2020' },
            rec601: { r: [0.630, 0.340], g: [0.310, 0.595], b: [0.155, 0.070], color: 'rgba(50, 150, 255, 0.8)', label: 'Rec.601' }
        };

        const scale = 500;
        const offsetX = 100;
        const offsetY = 525;

        function toCanvas(x, y) {
            return { x: x * scale + offsetX, y: offsetY - y * scale };
        }

        function fromCanvas(px, py) {
            // y = offsetY - py / scale => py = offsetY - y*scale
            // y*scale = offsetY - py => y = (offsetY - py)/scale
            // px = x*scale + offsetX => x = (px - offsetX)/scale
            return {
                x: (px - offsetX) / scale,
                y: (offsetY - py) / scale
            };
        }

        function pointInPolygon(point, vs) {
            // Ray-casting algorithm based on
            // https://github.com/ substack/point-in-polygon
            let x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                let xi = vs[i][0], yi = vs[i][1];
                let xj = vs[j][0], yj = vs[j][1];

                let intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Cache for the background image
        let backgroundCache = null;

        function generateGamutBackground() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tCtx = tempCanvas.getContext('2d');

            const w = tempCanvas.width;
            const h = tempCanvas.height;
            const imgData = tCtx.createImageData(w, h);
            const data = imgData.data;

            // Pre-calculate polygon for point checking
            // locus points + close the loop with [0.175596, 0.005296] (start)
            // Actually pointInPolygon handles implicit closing if we just iterate correctly or explicitly add start to end?
            // The function uses j=vs.length-1 for the first i=0, so it closes implicitly.

            for (let py = 0; py < h; py++) {
                for (let px = 0; px < w; px++) {
                    const xy = fromCanvas(px, py);
                    const x = xy.x;
                    const y = xy.y;

                    // Optimization: Bounding box check first (approx)
                    if (x < 0 || x > 0.8 || y < 0 || y > 0.9) continue;

                    if (pointInPolygon([x, y], locus)) {
                        // Convert xyY to XYZ (Y=1 for max brightness)
                        // Avoid division by zero
                        if (y <= 0) continue;

                        const Y = 1.0;
                        const X = (x * Y) / y;
                        const Z = ((1 - x - y) * Y) / y;

                        // XYZ to RGB (Linear sRGB / Rec. 709 primaries)
                        // Matrix:
                        //  3.2406 -1.5372 -0.4986
                        // -0.9689  1.8758  0.0415
                        //  0.0557 -0.2040  1.0570

                        let r = 3.2406 * X - 1.5372 * Y - 0.4986 * Z;
                        let g = -0.9689 * X + 1.8758 * Y + 0.0415 * Z;
                        let b = 0.0557 * X - 0.2040 * Y + 1.0570 * Z;

                        // Naive Gamut Mapping for Visualization:
                        // 1. Desaturate/Clip negative values by adding white? 
                        // Or just clamp to 0 and normalize max to 1?

                        // Simple robust approach for CIE charts:
                        // If any component is negative, we are out of gamut.
                        // We preserve hue by finding the dominant primary and scaling others? 
                        // Simplest valid visualization: Clamp negative to 0.
                        r = Math.max(0, r);
                        g = Math.max(0, g);
                        b = Math.max(0, b);

                        // Normalize brightness so we can see it
                        const max = Math.max(r, g, b);
                        if (max > 0) {
                            r /= max;
                            g /= max;
                            b /= max;
                        }

                        // Gamma Correct (sRGB ~2.2) 
                        // Just use pow 1/2.2 for simplicity
                        r = Math.pow(r, 1 / 2.2);
                        g = Math.pow(g, 1 / 2.2);
                        b = Math.pow(b, 1 / 2.2);

                        const idx = (py * w + px) * 4;
                        data[idx] = Math.min(255, r * 255);
                        data[idx + 1] = Math.min(255, g * 255);
                        data[idx + 2] = Math.min(255, b * 255);
                        data[idx + 3] = 255; // Alpha
                    }
                }
            }

            tCtx.putImageData(imgData, 0, 0);
            return tempCanvas;
        }

        function drawTriangle(p, style, fill) {
            const r = toCanvas(p.r[0], p.r[1]);
            const g = toCanvas(p.g[0], p.g[1]);
            const b = toCanvas(p.b[0], p.b[1]);

            ctx.beginPath();
            ctx.moveTo(r.x, r.y);
            ctx.lineTo(g.x, g.y);
            ctx.lineTo(b.x, b.y);
            ctx.closePath();

            ctx.lineWidth = 2;
            ctx.strokeStyle = style;
            ctx.stroke();

            if (fill) {
                ctx.fillStyle = style.replace('0.8', '0.15'); // Very transparent fill
                ctx.fill();
            }

            // Draw points
            [r, g, b].forEach(pt => {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = style;
                ctx.fill();
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Fill canvas background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Generate bg if needed
            if (!backgroundCache) {
                // Show loading text on first frame if slow? 
                // It's fast enough (~50-100ms) usually.
                backgroundCache = generateGamutBackground();
            }

            // Draw colorful gamut
            ctx.drawImage(backgroundCache, 0, 0);

            // Draw Locus Outline
            ctx.beginPath();
            const first = toCanvas(locus[0][0], locus[0][1]);
            ctx.moveTo(first.x, first.y);
            locus.forEach(pt => {
                const p = toCanvas(pt[0], pt[1]);
                ctx.lineTo(p.x, p.y);
            });
            ctx.closePath();
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Grid (Labels)
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            for (let i = 0; i <= 0.8; i += 0.1) {
                const pX = toCanvas(i, 0);
                ctx.fillText(i.toFixed(1), pX.x, pX.y + 15);
                const pY = toCanvas(0, i);
                ctx.fillText(i.toFixed(1), pY.x - 25, pY.y);
            }

            if (document.getElementById('show-rec2020').checked) drawTriangle(primaries.rec2020, primaries.rec2020.color, true);
            if (document.getElementById('show-srgb').checked) drawTriangle(primaries.srgb, primaries.srgb.color, true);
            if (document.getElementById('show-rec601').checked) drawTriangle(primaries.rec601, primaries.rec601.color, true);
        }

        ['show-srgb', 'show-rec2020', 'show-rec601'].forEach(id => {
            document.getElementById(id).addEventListener('change', draw);
        });

        // Initial draw might happen before style layout settles, but canvas size is fixed att 600x600 in attributes.
        // Use requestAnimationFrame to ensure valid context? No, strictly linear is fine here.
        setTimeout(draw, 10); // slightly async to let UI breathe
    })();
</script>