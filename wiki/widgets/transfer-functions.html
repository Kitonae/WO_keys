<div class="interactive-widget" id="transfer-function-widget">
    <canvas id="tf-canvas" width="800" height="500"></canvas>
    <div class="widget-controls">
        <label><input type="checkbox" id="show-srgb-tf" checked> sRGB</label>
        <label><input type="checkbox" id="show-gamma22-tf" checked> Gamma 2.2</label>
        <label><input type="checkbox" id="show-pq-tf" checked> PQ (ST 2084)</label>
        <label><input type="checkbox" id="show-hlg-tf" checked> HLG</label>
    </div>
    <div class="widget-explainer">
        Compare how different transfer functions map signal values to luminance. Note the <strong>logarithmic
            scale</strong> on the Y-axis.
    </div>
</div>
<script>
    (function () {
        const canvas = document.getElementById('tf-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Margins
        const margin = { top: 20, right: 100, bottom: 40, left: 60 };
        const graphW = width - margin.left - margin.right;
        const graphH = height - margin.top - margin.bottom;

        // Data curves
        // X = Input (0..1)
        // Y = Luminance (nits)
        // sRGB: max 80 nits
        // Gamma 2.2: max 100 nits (ref) or 80? Let's say 100 for SDR ref
        // HLG: max 1000 nits
        // PQ: max 10000 nits

        // We use a log scale for Y axis 1..10000
        const minNits = 1;
        const maxNits = 10000;
        const minLog = Math.log10(minNits);
        const maxLog = Math.log10(maxNits);
        const logRange = maxLog - minLog;

        function toY(nits) {
            let n = Math.max(minNits, nits);
            let log = Math.log10(n);
            let norm = (log - minLog) / logRange; // 0..1
            return margin.top + graphH - (norm * graphH);
        }

        function toX(val) {
            return margin.left + val * graphW;
        }

        // Transfer Functions (approx)

        // --- EOTF Implementations ---

        // sRGB EOTF (Signal 0..1 -> Luminance 0..80 nits)
        // Piecewise function: Linear near black, Power law (approx 2.4) elsewhere
        function sRGB_EOTF(v) {
            let val;
            if (v <= 0.04045) {
                val = v / 12.92;
            } else {
                val = Math.pow((v + 0.055) / 1.055, 2.4);
            }
            return val * 80; // Standard definition maps roughly to 80 nits peak
        }

        // Gamma 2.2 EOTF (Signal 0..1 -> Luminance 0..100 nits)
        // Simple power law
        function Gamma22_EOTF(v) {
            return Math.pow(v, 2.2) * 100; // Reference 100 nits
        }

        // PQ (Perceptual Quantizer) EOTF (Signal 0..1 -> Luminance 0..10000 nits)
        // SMPTE ST 2084
        function PQ_EOTF(v) {
            // Constants
            // Standard constants from SMPTE ST 2084
            const m1_val = 2610 / 16384; // 0.1593017578125
            const m2_val = 2523 / 4096 * 128; // 78.84375
            const c1 = 3424 / 4096; // 0.8359375
            const c2 = 2413 / 4096 * 32; // 18.8515625
            const c3 = 2392 / 4096 * 32; // 18.6875

            // Proper EOTF Formula:
            // L = ( ( max( N^(1/m2) - c1, 0 ) ) / ( c2 - c3 * N^(1/m2) ) ) ^ (1/m1)
            // Where N is the non-linear signal 0..1 (v in this function)

            const N_p = Math.pow(v, 1 / m2_val);
            const num = Math.max(N_p - c1, 0);
            const den = c2 - c3 * N_p;

            // Handle potential division by zero, though for v in [0,1] and standard constants, den should be > 0
            if (den === 0) return 10000; // Max luminance

            const val = Math.pow(num / den, 1 / m1_val);

            return val * 10000; // Scale to 10000 nits peak
        }

        // HLG (Hybrid Log-Gamma) EOTF (Signal 0..1 -> Luminance 0..1000 nits)
        // ARIB STD-B67
        // HLG is relative. We assume a 1000 nit peak display for this visualization.
        function HLG_EOTF(v) {
            // Constants from ARIB STD-B67
            const a = 0.17883277;
            const b = 1 - 4 * a; // 0.28466892
            const c = 0.5 - a * Math.log(4 * a); // 0.55991073

            // Inverse OETF (Signal -> Scene Linear Light 0..1)
            // This converts the HLG signal (v) back to linear scene light (E)
            let E;
            if (v <= 0.5) {
                // For v <= 0.5, OETF is E' = sqrt(3E)
                // So, E = (E')^2 / 3 = v^2 / 3
                E = (v * v) / 3;
            } else {
                // For v > 0.5, OETF is E' = a * ln(12E - b) + c
                // So, E = (exp((E' - c) / a) + b) / 12 = (exp((v - c) / a) + b) / 12
                E = (Math.exp((v - c) / a) + b) / 12;
            }

            // OOTF (Opto-Optical Transfer Function) for display
            // HLG EOTF includes a system gamma (OOTF) for display adaptation.
            // L = Lw * E^gamma
            // Lw is the nominal peak luminance of the display (e.g., 1000 nits).
            // gamma is typically 1.2 for HLG.
            const gamma = 1.2;
            const Lw = 1000; // Assuming a 1000 nit reference display

            return Lw * Math.pow(E, gamma);
        }


        function drawCurve(func, color, label, show) {
            if (!show) return;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            let moved = false;
            for (let i = 0; i <= 200; i++) {
                const x = i / 200; // 0..1
                const nits = func(x);

                const px = toX(x);
                const py = toY(nits);

                if (nits < minNits) continue; // Out of log graph range (below 1 nit)

                if (!moved) {
                    ctx.moveTo(px, py);
                    moved = true;
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();

            // Draw label at end
            const endNits = func(1.0);
            const pEnd = { x: toX(1.0), y: toY(endNits) };
            ctx.fillStyle = color;
            ctx.font = '12px sans-serif';
            ctx.fillText(label, pEnd.x + 5, pEnd.y + 4);
        }

        // Interaction state
        let mouseX = -1;

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Background
            ctx.fillStyle = '#1e1e24';
            ctx.fillRect(margin.left, margin.top, graphW, graphH);

            // Grid lines (Log Y)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';

            // Powers of 10
            for (let p = 0; p <= 4; p++) {
                const nits = Math.pow(10, p);
                const y = toY(nits);
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(width - margin.right, y);
                ctx.stroke();
                ctx.fillText(nits + (p === 4 ? ' nits' : ''), margin.left - 5, y + 4);
            }

            // Grid X (Input 0..1)
            ctx.textAlign = 'center';
            for (let i = 0; i <= 10; i++) {
                const v = i / 10;
                const x = toX(v);
                ctx.beginPath();
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, height - margin.bottom);
                ctx.stroke();
                if (i % 2 === 0) ctx.fillText(v, x, height - margin.bottom + 15);
            }

            // Axis labels
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.font = '12px sans-serif';
            ctx.fillStyle = '#aaa';
            ctx.fillText("Luminance (nits) - Log Scale", 0, 0);
            ctx.restore();

            ctx.textAlign = 'center';
            ctx.fillText("Input Signal (0.0 - 1.0)", margin.left + graphW / 2, height - 10);


            // Draw Curves
            const showSRGB = document.getElementById('show-srgb-tf').checked;
            const showGamma = document.getElementById('show-gamma22-tf').checked;
            const showPQ = document.getElementById('show-pq-tf').checked;
            const showHLG = document.getElementById('show-hlg-tf').checked;

            if (showSRGB) drawCurve(sRGB_EOTF, '#fcd34d', 'sRGB', true);
            if (showGamma) drawCurve(Gamma22_EOTF, '#f87171', 'Gamma 2.2', true);
            if (showHLG) drawCurve(HLG_EOTF, '#34d399', 'HLG', true);
            if (showPQ) drawCurve(PQ_EOTF, '#60a5fa', 'PQ', true);

            // Interaction - Crosshair
            if (mouseX >= margin.left && mouseX <= width - margin.right) {
                const v = (mouseX - margin.left) / graphW;
                const x = mouseX;

                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.setLineDash([5, 5]);
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, height - margin.bottom);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw dots and values
                const curves = [
                    { name: 'PQ', func: PQ_EOTF, color: '#60a5fa', show: showPQ },
                    { name: 'HLG', func: HLG_EOTF, color: '#34d399', show: showHLG },
                    { name: 'Gamma', func: Gamma22_EOTF, color: '#f87171', show: showGamma },
                    { name: 'sRGB', func: sRGB_EOTF, color: '#fcd34d', show: showSRGB },
                ];

                // Avoid overlap in labels
                // We sort by Y position 
                const points = curves.filter(c => c.show).map(c => {
                    const nits = c.func(v);
                    return { ...c, nits, y: toY(nits) };
                }).sort((a, b) => a.y - b.y); // top to bottom

                points.forEach(p => {
                    // Dot
                    ctx.beginPath();
                    ctx.arc(x, p.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();

                    // Box background for text
                    const txt = `${Math.round(p.nits)}`;
                    ctx.font = 'bold 12px monospace';
                    const tw = ctx.measureText(txt).width;

                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(x + 10, p.y - 10, tw + 10, 20);

                    ctx.fillStyle = p.color;
                    ctx.textAlign = 'left';
                    ctx.fillText(txt, x + 15, p.y + 4);
                });
            }
        }

        ['show-srgb-tf', 'show-gamma22-tf', 'show-pq-tf', 'show-hlg-tf'].forEach(id => {
            document.getElementById(id).addEventListener('change', draw);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            mouseX = -1;
            draw();
        });

        draw();
    })();
</script>